{
  "version": 3,
  "sources": ["../../../src/language/generated/ast.ts", "../../../src/language/generated/grammar.ts", "../../../src/language/generated/module.ts", "../../../src/language/common/tokenBuilder.ts", "../../../src/language/common/valueConverter.ts", "../../../src/language/common/matcher.ts"],
  "sourcesContent": ["/******************************************************************************\n * This file was generated by langium-cli 3.0.3.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\n/* eslint-disable */\nimport type { AstNode, ReferenceInfo, TypeMetaData } from 'langium';\nimport { AbstractAstReflection } from 'langium';\n\nexport const MermaidTerminals = {\n    NEWLINE: /\\r?\\n/,\n    ACC_DESCR: /[\\t ]*accDescr(?:[\\t ]*:([^\\n\\r]*?(?=%%)|[^\\n\\r]*)|\\s*{([^}]*)})/,\n    ACC_TITLE: /[\\t ]*accTitle[\\t ]*:(?:[^\\n\\r]*?(?=%%)|[^\\n\\r]*)/,\n    TITLE: /[\\t ]*title(?:[\\t ][^\\n\\r]*?(?=%%)|[\\t ][^\\n\\r]*|)/,\n    WHITESPACE: /[\\t ]+/,\n    YAML: /---[\\t ]*\\r?\\n(?:[\\S\\s]*?\\r?\\n)?---(?:\\r?\\n|(?!\\S))/,\n    DIRECTIVE: /[\\t ]*%%{[\\S\\s]*?}%%(?:\\r?\\n|(?!\\S))/,\n    SINGLE_LINE_COMMENT: /[\\t ]*%%[^\\n\\r]*/,\n    INT: /0|[1-9][0-9]*/,\n    STRING: /\"[^\"]*\"|'[^']*'/,\n    PIE_SECTION_LABEL: /\"[^\"]+\"/,\n    PIE_SECTION_VALUE: /(0|[1-9][0-9]*)(\\.[0-9]+)?/,\n};\n\nexport interface Common extends AstNode {\n    readonly $type: 'Common';\n    accDescr?: string;\n    accTitle?: string;\n    title?: string;\n}\n\nexport const Common = 'Common';\n\nexport function isCommon(item: unknown): item is Common {\n    return reflection.isInstance(item, Common);\n}\n\nexport interface Info extends AstNode {\n    readonly $type: 'Info';\n    accDescr?: string;\n    accTitle?: string;\n    title?: string;\n}\n\nexport const Info = 'Info';\n\nexport function isInfo(item: unknown): item is Info {\n    return reflection.isInstance(item, Info);\n}\n\nexport interface Packet extends AstNode {\n    readonly $type: 'Packet';\n    accDescr?: string;\n    accTitle?: string;\n    blocks: Array<PacketBlock>;\n    title?: string;\n}\n\nexport const Packet = 'Packet';\n\nexport function isPacket(item: unknown): item is Packet {\n    return reflection.isInstance(item, Packet);\n}\n\nexport interface PacketBlock extends AstNode {\n    readonly $container: Packet;\n    readonly $type: 'PacketBlock';\n    end?: number;\n    label: string;\n    start: number;\n}\n\nexport const PacketBlock = 'PacketBlock';\n\nexport function isPacketBlock(item: unknown): item is PacketBlock {\n    return reflection.isInstance(item, PacketBlock);\n}\n\nexport interface Pie extends AstNode {\n    readonly $type: 'Pie';\n    accDescr?: string;\n    accTitle?: string;\n    sections: Array<PieSection>;\n    showData: boolean;\n    title?: string;\n}\n\nexport const Pie = 'Pie';\n\nexport function isPie(item: unknown): item is Pie {\n    return reflection.isInstance(item, Pie);\n}\n\nexport interface PieSection extends AstNode {\n    readonly $container: Pie;\n    readonly $type: 'PieSection';\n    label: string;\n    value: number;\n}\n\nexport const PieSection = 'PieSection';\n\nexport function isPieSection(item: unknown): item is PieSection {\n    return reflection.isInstance(item, PieSection);\n}\n\nexport type MermaidAstType = {\n    Common: Common\n    Info: Info\n    Packet: Packet\n    PacketBlock: PacketBlock\n    Pie: Pie\n    PieSection: PieSection\n}\n\nexport class MermaidAstReflection extends AbstractAstReflection {\n\n    getAllTypes(): string[] {\n        return ['Common', 'Info', 'Packet', 'PacketBlock', 'Pie', 'PieSection'];\n    }\n\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\n        switch (subtype) {\n            default: {\n                return false;\n            }\n        }\n    }\n\n    getReferenceType(refInfo: ReferenceInfo): string {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n\n    getTypeMetaData(type: string): TypeMetaData {\n        switch (type) {\n            case 'Common': {\n                return {\n                    name: 'Common',\n                    properties: [\n                        { name: 'accDescr' },\n                        { name: 'accTitle' },\n                        { name: 'title' }\n                    ]\n                };\n            }\n            case 'Info': {\n                return {\n                    name: 'Info',\n                    properties: [\n                        { name: 'accDescr' },\n                        { name: 'accTitle' },\n                        { name: 'title' }\n                    ]\n                };\n            }\n            case 'Packet': {\n                return {\n                    name: 'Packet',\n                    properties: [\n                        { name: 'accDescr' },\n                        { name: 'accTitle' },\n                        { name: 'blocks', defaultValue: [] },\n                        { name: 'title' }\n                    ]\n                };\n            }\n            case 'PacketBlock': {\n                return {\n                    name: 'PacketBlock',\n                    properties: [\n                        { name: 'end' },\n                        { name: 'label' },\n                        { name: 'start' }\n                    ]\n                };\n            }\n            case 'Pie': {\n                return {\n                    name: 'Pie',\n                    properties: [\n                        { name: 'accDescr' },\n                        { name: 'accTitle' },\n                        { name: 'sections', defaultValue: [] },\n                        { name: 'showData', defaultValue: false },\n                        { name: 'title' }\n                    ]\n                };\n            }\n            case 'PieSection': {\n                return {\n                    name: 'PieSection',\n                    properties: [\n                        { name: 'label' },\n                        { name: 'value' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\n\nexport const reflection = new MermaidAstReflection();\n", "/******************************************************************************\n * This file was generated by langium-cli 3.0.3.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\nimport type { Grammar } from 'langium';\nimport { loadGrammarFromJson } from 'langium';\n\nlet loadedInfoGrammar: Grammar | undefined;\nexport const InfoGrammar = (): Grammar => loadedInfoGrammar ?? (loadedInfoGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Info\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Info\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"info\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"showInfo\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}'));\n\nlet loadedPacketGrammar: Grammar | undefined;\nexport const PacketGrammar = (): Grammar => loadedPacketGrammar ?? (loadedPacketGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Packet\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Packet\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"packet-beta\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"blocks\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PacketBlock\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"start\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"-\"},{\"$type\":\"Assignment\",\"feature\":\"end\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"INT\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/0|[1-9][0-9]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]*\\\\\"|\\'[^\\']*\\'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}'));\n\nlet loadedPieGrammar: Grammar | undefined;\nexport const PieGrammar = (): Grammar => loadedPieGrammar ?? (loadedPieGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"Pie\",\"imports\":[],\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Pie\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"pie\"},{\"$type\":\"Assignment\",\"feature\":\"showData\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"showData\"},\"cardinality\":\"?\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"*\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"Assignment\",\"feature\":\"sections\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]},\"cardinality\":\"+\"}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"*\"}]}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PieSection\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"label\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]}},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_LABEL\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"[^\\\\\"]+\\\\\"/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"PIE_SECTION_VALUE\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"number\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"ParserRule\",\"name\":\"TitleAndAccessibilities\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"accDescr\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"accTitle\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"title\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]}],\"cardinality\":\"+\"},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EOL\",\"fragment\":true,\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[],\"cardinality\":\"+\"},{\"$type\":\"EndOfFile\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"NEWLINE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\r?\\\\\\\\n/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_DESCR\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"ACC_TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"TITLE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WHITESPACE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"YAML\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"DIRECTIVE\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SINGLE_LINE_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"interfaces\":[{\"$type\":\"Interface\",\"name\":\"Common\",\"attributes\":[{\"$type\":\"TypeAttribute\",\"name\":\"accDescr\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"accTitle\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}},{\"$type\":\"TypeAttribute\",\"name\":\"title\",\"isOptional\":true,\"type\":{\"$type\":\"SimpleType\",\"primitiveType\":\"string\"}}],\"superTypes\":[]}],\"types\":[],\"usedGrammars\":[]}'));\n", "/******************************************************************************\n * This file was generated by langium-cli 3.0.3.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\nimport type { LangiumSharedCoreServices, LangiumCoreServices, LangiumGeneratedCoreServices, LangiumGeneratedSharedCoreServices, LanguageMetaData, Module } from 'langium';\nimport { MermaidAstReflection } from './ast.js';\nimport { InfoGrammar, PacketGrammar, PieGrammar } from './grammar.js';\n\nexport const InfoLanguageMetaData = {\n    languageId: 'info',\n    fileExtensions: ['.mmd', '.mermaid'],\n    caseInsensitive: false\n} as const satisfies LanguageMetaData;\n\nexport const PacketLanguageMetaData = {\n    languageId: 'packet',\n    fileExtensions: ['.mmd', '.mermaid'],\n    caseInsensitive: false\n} as const satisfies LanguageMetaData;\n\nexport const PieLanguageMetaData = {\n    languageId: 'pie',\n    fileExtensions: ['.mmd', '.mermaid'],\n    caseInsensitive: false\n} as const satisfies LanguageMetaData;\n\nexport const MermaidGeneratedSharedModule: Module<LangiumSharedCoreServices, LangiumGeneratedSharedCoreServices> = {\n    AstReflection: () => new MermaidAstReflection()\n};\n\nexport const InfoGeneratedModule: Module<LangiumCoreServices, LangiumGeneratedCoreServices> = {\n    Grammar: () => InfoGrammar(),\n    LanguageMetaData: () => InfoLanguageMetaData,\n    parser: {}\n};\n\nexport const PacketGeneratedModule: Module<LangiumCoreServices, LangiumGeneratedCoreServices> = {\n    Grammar: () => PacketGrammar(),\n    LanguageMetaData: () => PacketLanguageMetaData,\n    parser: {}\n};\n\nexport const PieGeneratedModule: Module<LangiumCoreServices, LangiumGeneratedCoreServices> = {\n    Grammar: () => PieGrammar(),\n    LanguageMetaData: () => PieLanguageMetaData,\n    parser: {}\n};\n", "import type { GrammarAST, Stream, TokenBuilderOptions } from 'langium';\nimport type { TokenType } from 'chevrotain';\n\nimport { DefaultTokenBuilder } from 'langium';\n\nexport abstract class AbstractMermaidTokenBuilder extends DefaultTokenBuilder {\n  private keywords: Set<string>;\n\n  public constructor(keywords: string[]) {\n    super();\n    this.keywords = new Set<string>(keywords);\n  }\n\n  protected override buildKeywordTokens(\n    rules: Stream<GrammarAST.AbstractRule>,\n    terminalTokens: TokenType[],\n    options?: TokenBuilderOptions\n  ): TokenType[] {\n    const tokenTypes: TokenType[] = super.buildKeywordTokens(rules, terminalTokens, options);\n    // to restrict users, they mustn't have any non-whitespace characters after the keyword.\n    tokenTypes.forEach((tokenType: TokenType): void => {\n      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string\n        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + '(?:(?=%%)|(?!\\\\S))');\n      }\n    });\n    return tokenTypes;\n  }\n}\n\nexport class CommonTokenBuilder extends AbstractMermaidTokenBuilder {}\n", "import type { CstNode, GrammarAST, ValueType } from 'langium';\nimport { DefaultValueConverter } from 'langium';\n\nimport { accessibilityDescrRegex, accessibilityTitleRegex, titleRegex } from './matcher.js';\n\nconst rulesRegexes: Record<string, RegExp> = {\n  ACC_DESCR: accessibilityDescrRegex,\n  ACC_TITLE: accessibilityTitleRegex,\n  TITLE: titleRegex,\n};\n\nexport abstract class AbstractMermaidValueConverter extends DefaultValueConverter {\n  /**\n   * A method contains convert logic to be used by class.\n   *\n   * @param rule - Parsed rule.\n   * @param input - Matched string.\n   * @param cstNode - Node in the Concrete Syntax Tree (CST).\n   * @returns converted the value if it's available or `undefined` if it's not.\n   */\n  protected abstract runCustomConverter(\n    rule: GrammarAST.AbstractRule,\n    input: string,\n    cstNode: CstNode\n  ): ValueType | undefined;\n\n  protected override runConverter(\n    rule: GrammarAST.AbstractRule,\n    input: string,\n    cstNode: CstNode\n  ): ValueType {\n    let value: ValueType | undefined = this.runCommonConverter(rule, input, cstNode);\n\n    if (value === undefined) {\n      value = this.runCustomConverter(rule, input, cstNode);\n    }\n    if (value === undefined) {\n      return super.runConverter(rule, input, cstNode);\n    }\n\n    return value;\n  }\n\n  private runCommonConverter(\n    rule: GrammarAST.AbstractRule,\n    input: string,\n    _cstNode: CstNode\n  ): ValueType | undefined {\n    const regex: RegExp | undefined = rulesRegexes[rule.name];\n    if (regex === undefined) {\n      return undefined;\n    }\n    const match = regex.exec(input);\n    if (match === null) {\n      return undefined;\n    }\n    // single line title, accTitle, accDescr\n    if (match[1] !== undefined) {\n      return match[1].trim().replace(/[\\t ]{2,}/gm, ' ');\n    }\n    // multi line accDescr\n    if (match[2] !== undefined) {\n      return match[2]\n        .replace(/^\\s*/gm, '')\n        .replace(/\\s+$/gm, '')\n        .replace(/[\\t ]{2,}/gm, ' ')\n        .replace(/[\\n\\r]{2,}/gm, '\\n');\n    }\n    return undefined;\n  }\n}\n\nexport class CommonValueConverter extends AbstractMermaidValueConverter {\n  protected override runCustomConverter(\n    _rule: GrammarAST.AbstractRule,\n    _input: string,\n    _cstNode: CstNode\n  ): ValueType | undefined {\n    return undefined;\n  }\n}\n", "/**\n * Matches single and multi line accessible description\n */\nexport const accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\n\n/**\n * Matches single line accessible title\n */\nexport const accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\n\n/**\n * Matches a single line title\n */\nexport const titleRegex = /title([\\t ][^\\n\\r]*|)/;\n"],
  "mappings": "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",
  "names": []
}
