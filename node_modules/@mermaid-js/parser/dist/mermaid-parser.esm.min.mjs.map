{
  "version": 3,
  "sources": ["../src/parse.ts"],
  "sourcesContent": ["import type { LangiumParser, ParseResult } from 'langium';\n\nimport type { Info, Packet, Pie } from './index.js';\n\nexport type DiagramAST = Info | Packet | Pie;\n\nconst parsers: Record<string, LangiumParser> = {};\nconst initializers = {\n  info: async () => {\n    const { createInfoServices } = await import('./language/info/index.js');\n    const parser = createInfoServices().Info.parser.LangiumParser;\n    parsers.info = parser;\n  },\n  packet: async () => {\n    const { createPacketServices } = await import('./language/packet/index.js');\n    const parser = createPacketServices().Packet.parser.LangiumParser;\n    parsers.packet = parser;\n  },\n  pie: async () => {\n    const { createPieServices } = await import('./language/pie/index.js');\n    const parser = createPieServices().Pie.parser.LangiumParser;\n    parsers.pie = parser;\n  },\n} as const;\n\nexport async function parse(diagramType: 'info', text: string): Promise<Info>;\nexport async function parse(diagramType: 'packet', text: string): Promise<Packet>;\nexport async function parse(diagramType: 'pie', text: string): Promise<Pie>;\nexport async function parse<T extends DiagramAST>(\n  diagramType: keyof typeof initializers,\n  text: string\n): Promise<T> {\n  const initializer = initializers[diagramType];\n  if (!initializer) {\n    throw new Error(`Unknown diagram type: ${diagramType}`);\n  }\n  if (!parsers[diagramType]) {\n    await initializer();\n  }\n  const parser: LangiumParser = parsers[diagramType];\n  const result: ParseResult<T> = parser.parse<T>(text);\n  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {\n    throw new MermaidParseError(result);\n  }\n  return result.value;\n}\n\nexport class MermaidParseError extends Error {\n  constructor(public result: ParseResult<DiagramAST>) {\n    const lexerErrors: string = result.lexerErrors.map((err) => err.message).join('\\n');\n    const parserErrors: string = result.parserErrors.map((err) => err.message).join('\\n');\n    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n  }\n}\n"],
  "mappings": "sbAMA,IAAMA,EAAyC,CAAC,EAC1CC,EAAe,CACnB,KAAMC,EAAA,SAAY,CAChB,GAAM,CAAE,mBAAAC,CAAmB,EAAI,KAAM,QAAO,mDAA0B,EAChEC,EAASD,EAAmB,EAAE,KAAK,OAAO,cAChDH,EAAQ,KAAOI,CACjB,EAJM,QAKN,OAAQF,EAAA,SAAY,CAClB,GAAM,CAAE,qBAAAG,CAAqB,EAAI,KAAM,QAAO,qDAA4B,EACpED,EAASC,EAAqB,EAAE,OAAO,OAAO,cACpDL,EAAQ,OAASI,CACnB,EAJQ,UAKR,IAAKF,EAAA,SAAY,CACf,GAAM,CAAE,kBAAAI,CAAkB,EAAI,KAAM,QAAO,kDAAyB,EAC9DF,EAASE,EAAkB,EAAE,IAAI,OAAO,cAC9CN,EAAQ,IAAMI,CAChB,EAJK,MAKP,EAKA,eAAsBG,EACpBC,EACAC,EACY,CACZ,IAAMC,EAAcT,EAAaO,CAAW,EAC5C,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,yBAAyBF,CAAW,EAAE,EAEnDR,EAAQQ,CAAW,GACtB,MAAME,EAAY,EAGpB,IAAMC,EADwBX,EAAQQ,CAAW,EACX,MAASC,CAAI,EACnD,GAAIE,EAAO,YAAY,OAAS,GAAKA,EAAO,aAAa,OAAS,EAChE,MAAM,IAAIC,EAAkBD,CAAM,EAEpC,OAAOA,EAAO,KAChB,CAjBsBT,EAAAK,EAAA,SAmBf,IAAMK,EAAN,cAAgC,KAAM,CAC3C,YAAmBD,EAAiC,CAClD,IAAME,EAAsBF,EAAO,YAAY,IAAKG,GAAQA,EAAI,OAAO,EAAE,KAAK;AAAA,CAAI,EAC5EC,EAAuBJ,EAAO,aAAa,IAAKG,GAAQA,EAAI,OAAO,EAAE,KAAK;AAAA,CAAI,EACpF,MAAM,mBAAmBD,CAAW,IAAIE,CAAY,EAAE,EAHrC,YAAAJ,CAInB,CApDF,MA+C6C,CAAAT,EAAA,0BAM7C",
  "names": ["parsers", "initializers", "__name", "createInfoServices", "parser", "createPacketServices", "createPieServices", "parse", "diagramType", "text", "initializer", "result", "MermaidParseError", "lexerErrors", "err", "parserErrors"]
}
